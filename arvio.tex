\chapter{Tulosten arviointi ja pohdinta}
\label{ch:arviointi}
Diplomityössä toteutettu ohjelma ei ole ollut tuotannossa osana muuta järjestelmää vielä kovin kauan. Kuitenkin tähän mennessä se on toiminut ongelmitta. Varmasti ei voida arvioida, että ohjelmassa ei tulisi ongelmia tulevaisuudessa, mutta ainakin alun perusteella tulokset näyttävät toimivilta. Tältä osin voidaan arvioida, että diplomityö pääsi asetettuihin tavoitteisiin onnistuneesti ja halutut vaatimukset saatiin täytettyä. Kuitenkin toimivuudesta huolimatta toteutuksessa on kohtia mitä voitaisiin parantaa, tehdä toisin ja jatkokehittää. Nämä ovat kuitenkin tulevaisuudessa yrityksen sisällä tehtäviä työtehtäviä tai mahdollisesti toisen diplomityön aiheita.

Työn aikana järjestelmän hajautukseen pohdittiin eri paradigmojen sopivuutta ja huomattiin, että siihen sopisivat julkaisija-tilaaja-, joukkokommunikointi- ja viestijono-pa\-ra\-dig\-mat. Toteutukseen valittiin AMQP-standardi, joka mahdollisti julkaisija-tilaaja- ja viestijono-pa\-ra\-dig\-mat, mutta ei suoraan ollut tarkoitettu joukkokommunikointiin. Tämän takia joukkokommunikointi jätettiin pois ja korvattiin julkaisija-tilaaja-paradigmalla. Kuinka hyvin joukkokommunikointi olisi sopinut toteutukseen ei ole tarkkaa tietoa. Kuitenkin julkaisija-tilaajan-paradigma jatkaa IEC 61850 -standardin määrittämää julkaisija-tilaaja-kom\-mu\-ni\-koin\-ti\-a IED-laitteen kanssa ja näin ollen sopii toteutukseen hyvin. Toteutukseen myös harkittiin MQTT-standardia AMQP:n sijaan, joka on pelkästään julkaisija-tilaaja-kom\-mu\-ni\-koin\-tiin tarkoitettu protokolla. Tämä valinta tehtiin tekijän aikaisemman kokemuksen ja muiden yrityksessä olevien henkilöiden keskustelun pohjalta. Koska joukkokommunikointi jätettiin pois toteutuksesta, olisi MQTT voinut sopia toteutukseen paremmin kuin AMQP sen keveyden takia.

IED-laitteelta tuleva viesti päätettiin muuntaa JSON-muotoon XML:än sijaan. Vertailua kahden välillä tehtiin ja päätös oli aikaisemmin tutkimuksen perusteella selvä. JSON-muoto on kevyempi kuin XML ja sopii nykypäivänä viesti muotona hajautettuun järjestelmään hyvin. Suunniteltu JSON-rakenne on toiminut käytössä olemisen ajan tarpeiden mukaan. Kuitenkin siinä olisi kohtia mitä pystyisi toteuttamaan toisin. Esimerkiksi \emph{bit-string} tyypin bittijärjestys (engl. endian) voi vaihdella attribuuttien välillä ja tämän takia siitä JSON-viestiin julkaistiin kaksi eri arvoa \emph{valueLittleEndian} ja \emph{valueBigEndian} (liite \ref{ch:report-json-format} rivit 23--24). Käytännössä vastuu muuttujan oikein lukemisesta siirretään tilaajalle. Standardissa kuitenkin on määritetty, kuinka päin attribuutti esitetään, jos se on tyyppiä bit-string. Tämän vastuun voisi mahdollisesti siirtää rcb\_sub-ohjelman puolelle ja tarjota JSON-viestissä pelkkä \emph{value}-kenttä, niin kuin kaikille muillekin attribuuteille. Tämän lisäksi aikatyypit \emph{utc-time} JSON-viestissä päätettiin antaa siinä muodossa missä ne tulevat IED-laitteelta, eli millisekunteja UNIX-ajanlaskusta. JSON ei määritä käytettävää aikaformaattia, mutta JSON-rajapintoihin suositellaan käytettäväksi ISO 8601 -standardin aikaformaattia \cite{json-api-specification}.

Ennen varsinaista toteutusta demoon liittyviä ongelmien analyysista saatiin tuloksia suorituskykyyn liittyen. Näiden tietojen pohjalta ohjelman kieleksi valittiin C-kieli suorituskyvyn takia. Ongelmana demon suorituskyvyssä ei pelkästään ollut IED-laitteelta tulevien viestien määrä ja libIEC61850-kirjaston lukitus funktiokutsuissa. Todennäköisesti suurin syy oli Ruby-oletustulkin GIL, joka rajoittaa vain yhden säikeen suorituksen kerrallaan ja estää rinnakkaisuuden. C-kielen valinta oli hyvä ratkaisu. Ohjelman aika kaikkien RCB-instanssien tilaamiseen saatiin alas noin 30 sekunnista alle 15 sekuntiin. Suurin osa ajasta tulee IED-laitteille tehtävien kutsujen määrästä. Demon muistinkäyttö Ruby on Rails -ympäristössä oli noin 150 Mt. Rcb\_sub:in muistin käyttö saatiin noin 4 kt, joka on todella iso muutos aikaisempaan nähden. Tekniikan valinnan suhteen päätökset onnistuivat hyvin.

Ohjelman kehityksen aikana noudatettiin C-ohjelmoinnin tietoturvaa. Tarkoituksena välttää sen yleisimpiä virheitä, esimerkiksi tekstin formatointihyökkäys \cite{format-string-attack} ja muistin ylivuoto \cite{buffer-overflow-attack}. Tähän käytettiin apuna GCC-kääntäjän vipuja esimerkiksi \texttt{-Wall} ja \texttt{-Wextra} \cite{gcc-manual-warnings}. Huolellisesta ohjelmoinnista huolimatta järjestelmään tulee tietoa ulkopuoliselta IED-laitteelta, joka voi sisältää vahingollista tietoa. Tämä osuus jätettiin pois, koska se ei kuulunut tämän diplomityön aiheen piiriin. Tietoturvaa kuitenkin täytyy tarkistaa läpi tulevaisuudessa.

Järjestelmä aloittaa tilauksen käynnistämällä yhden rcb\_sub-prosessin per IED-laite. Tieto prosessille annettaan komentoriviparametreilla. Tilauksen muuttuessa, prosessi täytyy käynnistää uudelleen. Työn tekohetkellä ratkaisu sopi tarkoituksiin hyvin. Ratkaisuna olisi myös voinut toteuttaa yhden rcb\_sub-prosessin, joka pystyisi tilaamaan monta eri IED-laitetta rinnakkain, tai yhden IED-laitteen tilausta voisi muuttaa ilman, että prosessia täytyy käynnistää uudelleen. Tähän toteutustapaan tiedonsiirto komentoriviparametreilla ei enää onnistuisi vaan tarvittaisiin joku muu kommunikointitapa. Tähän sopisi aikaisemmin käsitellyt prosessien väliset kommunikointiparadigmat, esimerkiksi soketit. Toteutuksessa monen eri rcb\_sub-prosessin tilaamat viestit ohjataan saman RabbitMQ-palvelin kautta eri reititysavaimilla. Järjestelmän skaalautuessa isommaksi joutuu RabbitMQ isomman kuorman alle, joka todennäköisesti muodostuu pullonkaulaksi. Tarkkoja rajoja tähän ei vielä tiedetä ja nykyinen keskitetty RabbitMQ-palvelin todettiin riittäväksi tarkoituksiin tällä hetkellä. Kuitenkin tulevaisuudessa tämä on asia mikä täytyy ottaa huomioon.

Ohjelma jätettiin työssä pisteeseen, missä se saavutti kaikki sille asetetut vaatimukset. Kuitenkin tulevaisuudessa ohjelmaa voidaan lisätä ominaisuuksia tarpeen vaatiessa. Isoin puute ohjelmassa oli testiympäristö ja sen yksikkötestit. C:ssä ei ole suoraan tukea yksikkötestien kirjoittamiseen. Ympäristön pystytys vaatii erillisen kirjaston projektin yhteyteen millä yksikkötestit kirjoitetaan. Yksikkötestit ovat tärkeä osa ohjelman ylläpitoa ja toiminnan varmistamista muutosten jälkeen. Testiympäristön ja testien toteuttaminen jäi tulevaisuuden kehitystyöksi.

Tässä diplomityössä suunniteltu arkkitehtuuri ja ohjelmistoratkaisut toimisivat muissakin saman tyylisissä järjestelmissä, missä kommunikoidaan IEC 61850 -standardin mukaisesti ja tietoa julkaistaan eteenpäin. Periaatteessa suunnitelmasta olisi mahdollista toteuttaa oma kokonaisuutensa, jota olisi mahdollistaa käyttää muunkin järjestelmän kanssa. Tämä vaatisi kuitenkin tarkempaa suunnittelua ja edellä pohdittujen vaihtoehtojen käsittelyä.